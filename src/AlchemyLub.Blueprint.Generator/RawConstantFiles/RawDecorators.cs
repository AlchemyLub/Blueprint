namespace AlchemyLub.Blueprint.Generator.RawConstantFiles;

internal static class RawDecorators
{
    internal const string DependencyInjectionDecoratorMethods =
"""
// <auto-generated/>

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace DecoratorGenerator.Decorators
{
    public static class DependencyInjectionDecorator_generated
    {
        /// <summary>
        /// Декорирует сервисы, имплементирующие <typeparamref name="TInterface"/>
        /// </summary>
        /// <typeparam name="TInterface">Интерфейс декорируемого сервиса</typeparam>
        /// <typeparam name="TDecorator">Реализация декоратора</typeparam>
        /// <param name="services"><see cref="IServiceCollection"/></param>
        /// <returns><see cref="IServiceCollection"/></returns>
        /// <exception cref="DecoratingServicesNotFoundException"/>
        public static IServiceCollection Decorate<TInterface, TDecorator>(this IServiceCollection services)
            where TInterface : class
            where TDecorator : class, TInterface
        {
            Type interfaceType = typeof(TInterface);

            List<ServiceDescriptor> wrappedDescriptors = services
                .Where(t => t.ServiceType == interfaceType)
                .ToList();

            if (wrappedDescriptors.Count == 0)
            {
                throw new DecoratingServicesNotFoundException(interfaceType);
            }

            foreach (ServiceDescriptor wrappedDescriptor in wrappedDescriptors)
            {
                Func<IServiceProvider, object> factory = CreateFactory(
                    typeof(TDecorator),
                    wrappedDescriptor);

                services.Replace(ServiceDescriptor.Describe(
                        interfaceType,
                        factory,
                    wrappedDescriptor.Lifetime));
            }

            return services;
        }

        private static Func<IServiceProvider, object> CreateFactory(
            Type decoratorType,
            ServiceDescriptor currentDescriptor)
        {
            if (currentDescriptor.ImplementationInstance is not null)
            {
                return serviceProvider => ActivatorUtilities.CreateInstance(
                    serviceProvider,
                    decoratorType,
                    currentDescriptor.ImplementationInstance);
            }

            if (currentDescriptor.ImplementationFactory is not null)
            {
                return serviceProvider => ActivatorUtilities.CreateInstance(
                    serviceProvider,
                    decoratorType,
                    currentDescriptor.ImplementationFactory(serviceProvider));
            }

            if (currentDescriptor.ImplementationType is not null)
            {
                if (decoratorType.IsGenericTypeDefinition)
                {
                    return serviceProvider =>
                    {
                        object service = ActivatorUtilities.GetServiceOrCreateInstance(
                            serviceProvider,
                            currentDescriptor.ImplementationType);

                        Type[] genericArguments = currentDescriptor.ServiceType.GetGenericArguments();
                        Type closedDecorator = decoratorType.MakeGenericType(genericArguments);

                        return ActivatorUtilities.CreateInstance(
                            serviceProvider,
                            closedDecorator,
                            service);
                    };
                }

                return serviceProvider =>
                {
                    object service = ActivatorUtilities.GetServiceOrCreateInstance(
                        serviceProvider,
                        currentDescriptor.ImplementationType);

                    return ActivatorUtilities.CreateInstance(
                        serviceProvider,
                        decoratorType,
                        service);
                };
            }

            if (currentDescriptor.IsKeyedService)
            {
                if (currentDescriptor.KeyedImplementationInstance is not null)
                {
                    return serviceProvider => ActivatorUtilities.CreateInstance(
                        serviceProvider,
                        decoratorType,
                        currentDescriptor.KeyedImplementationInstance);
                }

                if (currentDescriptor.KeyedImplementationFactory is not null)
                {
                    return serviceProvider => ActivatorUtilities.CreateInstance(
                        serviceProvider,
                        decoratorType,
                        currentDescriptor.KeyedImplementationFactory(serviceProvider, currentDescriptor.ServiceKey));
                }

                if (currentDescriptor.KeyedImplementationType is not null)
                {
                    return serviceProvider =>
                    {
                        object service = ActivatorUtilities.CreateInstance(
                            serviceProvider,
                            currentDescriptor.KeyedImplementationType);

                        return ActivatorUtilities.CreateInstance(
                            serviceProvider,
                            decoratorType,
                            service);
                    };
                }
            }

            throw new NotImplementedException("Нужная корректная ошибка!");
        }

        private static IServiceCollection Replace(
            this IServiceCollection collection,
            ServiceDescriptor descriptor)
        {
            for (int index = 0; index < collection.Count; ++index)
            {
                if (collection[index].ServiceType == descriptor.ServiceType && Equals(collection[index].ServiceKey, descriptor.ServiceKey))
                {
                    collection.RemoveAt(index);
                    break;
                }
            }
            collection.Add(descriptor);
            return collection;
        }
    }
}
""";
}
